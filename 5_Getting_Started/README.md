# 5. Getting Started
并行化顺序代码有几种关键策略。虽然将这些策略应用于特定应用程序的详细过程是复杂且特定问题相关的，但以下列出的通用主题适用于并行化在多核 CPU 上运行的代码，或在 CUDA GPU 上使用的代码。

## 5.1. Parallel Libraries
最直接的应用程序并行化方法是利用现有的库，这些库可以代表我们利用并行架构。CUDA 工具包包括许多经过微调以适用于 NVIDIA CUDA GPU 的库，如 cuBLAS、cuFFT 等。

关键在于，库在与应用程序需求良好匹配时最为有用。例如，已经使用其他 BLAS 库的应用程序通常可以很容易地切换到 cuBLAS，而几乎不涉及线性代数的应用程序则几乎不会使用 cuBLAS。其他 CUDA 工具包库也是如此：cuFFT 的接口类似于 FFTW 等。

需要注意的是 Thrust 库，这是一个类似于 C++ 标准模板库的并行 C++ 模板库。Thrust 提供了一系列丰富的数据并行原语，如扫描、排序和归约，这些原语可以组合在一起，用简洁、可读的源代码实现复杂算法。通过基于这些高级抽象描述计算，您可以让 Thrust 自由选择最有效的实现。 因此，Thrust 可以用于 CUDA 应用程序的快速原型设计（其中开发人员生产力最为重要）以及生产环境（其中健壮性和绝对性能至关重要）。

## 5.2. Parallelizing Compilers
另一种常见的顺序代码并行化方法是使用并行化编译器。通常这意味着使用基于指令的方法，其中程序员使用 #pragma 或其他类似符号向编译器提供有关并行化的位置提示，而无需修改或调整底层代码本身。通过向编译器揭示并行性，指令允许编译器完成将计算映射到并行架构的详细工作。\
OpenACC 标准提供了一组编译器指令，用于指定标准 C、C++ 和 Fortran 代码中的循环和区域，这些循环和区域应从主机 CPU 卸载到连接的加速器（例如 CUDA GPU）。加速器设备的管理细节由支持 OpenACC 的编译器和运行时隐式处理。\
See http://www.openacc.org/ for details.

## 5.3. Coding to Expose Parallelism
对于需要超越现有并行库或并行化编译器所提供的功能或性能的应用程序来说，像 CUDA C++ 这样能够与现有顺序代码无缝集成的并行编程语言是必不可少的。\
一旦在应用程序的性能分析中定位了热点，并确定自定义代码是最佳方法，我们可以使用 CUDA C++ 将代码中这一部分的并行性暴露为 CUDA 内核。然后，我们可以将这个内核部署到 GPU 上，并在不需要对应用程序的其他部分进行重大重写的情况下检索结果。\
这种方法在应用程序的大部分运行时间花费在代码中几个相对独立的部分时最为直接。更难以并行化的是那些具有非常平坦性能分析的应用程序，即时间分布相对均匀地分散在代码库的广泛部分的应用程序。对于后者类型的应用程序，可能需要进行一定程度的代码重构以揭示应用程序的固有并行性，但请记住，这种重构工作将有助于所有未来的架构，包括 CPU 和 GPU，因此，如果有必要，这项工作是非常值得的。